#!/usr/bin/env python3
from typing import Dict
import boto3, botocore
import json
import argparse
import json
import logging
import pathlib
import time

from rich import print
from rich.console import Console as RichConsole


###################################################
# Input Variables
parser = argparse.ArgumentParser()
optionalNamed = parser.add_argument_group('optional named arguments')
optionalNamed.add_argument("-p","--profile",default='default',type=str,help="The AWS profile to use")
optionalNamed.add_argument("--env",type=str,help="Use Environment Variables rather than an AWS profile")
optionalNamed.add_argument("--region",type=str,help="To enumerate the policies for a specific region (defaults to all regions)")
optionalNamed.add_argument("--log",default='info',type=str,help="The logging level (debug,info,warning,error,critical)")
optionalNamed.add_argument("--not-allowed-regions",type=str,help="Use Environment Variables rather than an AWS profile")

# Get the passed arguements
args = parser.parse_args()


###################################################
# Helper functions

def find_not_allowed_regions():
    # Want to determine which regions are not allowed according to SCPs
    # Cant use global service to do this test, such as iam/sts/s3 etc
    # https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_scps_examples_general.html#example-scp-deny-region
    # Will use sqs.list_queues for now, but that assume that the calling principal has the permission to perform this action (before SCPs deny it)
    regions = s.get_available_regions('sqs')
    not_allowed_regions = []
    for region in regions:
        try:
            sqs = s.client('sqs',region_name=region)
            sqs.list_queues()
            logger.debug(f"Region {region} is allowed")
        except:
            not_allowed_regions.append(region)
            logger.debug(f"Region {region} is not allowed")
    return not_allowed_regions

def write_output(filename,results):
    with open(filename, 'w') as outputfile:
        ## Need to make indentation an option
        json.dump(results, outputfile, indent=4)

def save_data(filename,data):
    # Make output dir if it doesnt exist
    output_dir = pathlib.Path(__file__).parent.absolute() / 'output'
    output_dir.mkdir(exist_ok=True)
    filepath = output_dir / filename
    with filepath.open("w") as write_file:
        json.dump(data, write_file, indent=4, default=str)


def pagniated_query(service_name: str,function_name: str,output_key: str,resource_type:str,params: Dict = None,specific_region: str =None):
    if specific_region == None:
        regions = s.get_available_regions(service_name)
        regions = [i for i in regions if i not in not_allowed_regions]
    else:
        regions = [specific_region]

    output = []
    for region in regions:
        logger.debug(f"Enumerating {resource_type}s for {region}")
        service_client = s.client(service_name,region_name=region)
        func = getattr(service_client, function_name)

        regional_output = []
        try:
            response = func()
            regional_output.extend(response[output_key])
            while 'nextToken' in response.keys():
                response = func(nextToken = response['nextToken'])
                regional_output.extend(response[output_key])
        except botocore.exceptions.ClientError as e:
            logging.warning("Unexpected error for region %s: %s" % (region,e))
            continue

        if not regional_output:
            logger.info(f"No {resource_type}s found in {region}")
            continue

        logger.info(f"Found {len(regional_output)} {resource_type}s in {region}")
        output.extend(regional_output)
    return output

###################################################
# Service functions

def enumerate_ssm_managed_nodes_and_run_command(specific_region):
    
    ssm_instances = pagniated_query('ssm','describe_instance_information',resource_type='SSM Managed EC2 Instance',output_key='InstanceInformationList',specific_region=specific_region)
    ssm_instance_ids = [i['InstanceId'] for i in ssm_instances]
    # ec2_instances = pagniated_query('ec2','describe_instances',resource_type='EC2 Instance' ,output_key='Reservations',)
    # ec2_instance_ids = [i['InstanceId'] for r in ec2_instances for i in r['Instances']]
    # unmanaged_nodes = [i for i in ec2_instance_ids if i not in ssm_instance_ids]
    # logging.debug(f"Unmanaged EC2 Nodes: {unmanaged_nodes}")
    
    print(f"Please select the index of an SSM Managed EC2 Instance to execute Send-Command against:")
    for index, instance in enumerate(ssm_instances,1):
        print(f"{index}. {instance['InstanceId']}")
        print(instance)


    from rich.prompt import IntPrompt, Prompt, Confirm
    
    index = IntPrompt.ask("Enter instance index", choices=[str(x) for x in list(range(1,len(ssm_instances)+1))], default="1")
    chosen_instance = ssm_instances[int(index)-1]
    chosen_instance_id = chosen_instance['InstanceId']
    print(f"You selected index {index} ({chosen_instance_id})")

    completed = False
    while completed == False:
        command = Prompt.ask("Enter the command you would like to run", default="hostname && cat /etc/passwd")
        print(f"You entered '{command}'")
        completed = Confirm.ask("Are you happy with this?")


    ssm = s.client('ssm')
    ## Send the command off
    response = ssm.send_command(
                InstanceIds=[chosen_instance_id],
                DocumentName="AWS-RunShellScript",
                Parameters={'commands': [x.strip() for x in command.split("&&")]}, )

    command_id = response['Command']['CommandId']

    ## Wait for the command to complete executing
    with console.status("Waiting for command to complete execution"):
        while ssm.get_command_invocation(CommandId=command_id,InstanceId=chosen_instance_id,)["Status"] == "InProgress":
            time.sleep(1)

    ## Get the STDOUT from the command invocation
    output = ssm.get_command_invocation(
        CommandId=command_id,
        InstanceId=chosen_instance_id,
        )["StandardOutputContent"]
    print(output)

###################################################
# Setup Logging
numeric_level = getattr(logging, args.log.upper(), None)
if not isinstance(numeric_level, int):
    raise ValueError('Invalid log level: %s' % args.log)

class CustomFormatter(logging.Formatter):
    grey = "\x1b[38;20m"
    yellow = "\x1b[33;20m"
    red = "\x1b[31;20m"
    bold_red = "\x1b[31;1m"
    reset = "\x1b[0m"
    date = "%(asctime)s"
    level = "%(levelname)s"
    message = "%(message)s"
    format = "%(asctime)s - %(levelname)s - %(message)s"
    # You can modify what the logger's messages look like here
    FORMATS = {
        logging.DEBUG: f"{grey}{level}{reset} - {message}",
        logging.INFO: f"{grey}{level}{reset} - {message}",
        logging.WARNING: f"{yellow}{level}{reset} - {message}",
        logging.ERROR: f"{red}{level}{reset} - {message}",
        logging.CRITICAL: f"{bold_red}{level}{reset} - {message}",
    }
    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)

# Use a logger (dont use logging.BasicConfig as boto also uses logging, and configuring it at the global level will make boto logs flood the stdout - need to use a logger specific to this script)
logger = logging.getLogger(__name__)
logger.setLevel(numeric_level)
# Need to configure a streamhandler to print to stdout
ch = logging.StreamHandler()
logger.addHandler(ch)
ch.setFormatter(CustomFormatter())


### Rich

console = RichConsole()

###################################################
# Actual logic

# Create the boto session
if args.env:
    s = boto3.session.Session()
else:
    s = boto3.session.Session(profile_name=args.profile)


# Check that the profile creds are valid
sts = s.client('sts')
try:
    sts_info = sts.get_caller_identity()
    account_id = sts_info.get('Account')
    logger.info(f"Using profile {args.profile} in account {account_id} with ARN {sts_info.get('Arn')}")
except sts.exceptions.ClientError as e:
    logger.critical(f"{e}")
    logger.critical(f"Exiting..")
    exit()

# Get a list of regions blocked by the SCP to reduce the errors thrown when enumerating the resource-policies across all regions
if not args.region:
    logger.debug("Determining which regions are not allowed")
    # not_allowed_regions = find_not_allowed_regions()
    
    not_allowed_regions = args.not_allowed_regions if args.not_allowed_regions is not None else find_not_allowed_regions()
    if not_allowed_regions:
        logger.debug(f"Not allowed regions: {not_allowed_regions}")
    else:
        logger.debug("All regions are allowed")

enumerate_ssm_managed_nodes_and_run_command(specific_region=args.region)
